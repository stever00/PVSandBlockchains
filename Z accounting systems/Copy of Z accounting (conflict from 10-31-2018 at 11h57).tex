\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\usepackage{z-eves}

\usepackage{xcolor}

\title{$\mathbf{Z^{Ac}}$---Formalising accounting systems in Z}
\author{Steve Reeves}
\date{}                                           % Activate to display a given date or no date

\begin{document}
\maketitle
%\section{}
%\subsection{}

\section{The basic systems}

\subsection{Single-entry}\label{singlebasic}

Here a transaction leads to an entry in one single account. And the record for this account is just a sequence of transactions, perhaps written as lines in a ledger. 

Typically a transaction is given by a date, a description and an amount, which is either added to the money a company owns (i.e. someone pays it money, say or goods or services) or taken from (it pays someone money, say because they buy some raw materials or for running-costs). So, an entry might be

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
Date & Description & Amount \\
\hline \hline
1st January 2017 & Sold Tissot watch & \$250.00\\
\hline
3rd March 2017 &  Bought can of oil & -\$40.00
\end{tabular}
\end{center}
\label{default}
\end{table}%

A slightly more refined version might split the ``Amount" column into ``Income" and ``Expenditure" 

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|}
Date & Description & Income & Expenditure \\
\hline \hline
1st January 2017 & Sold Tissot watch & \$250.00 & \\
\hline
3rd March 2017 &  Bought can of oil & & \$40.00
\end{tabular}
\end{center}
\label{default}
\end{table}%

\noindent just to make things rather clearer. But there would still be just one account involved: the money we currently hold in the company. The name single-entry comes from the fact that each transaction talks about (the same) single account. (See Ijiri's point about what the ``double" in double-entry refers to \cite{}.)

This way of running a company (the experts tell us, and the laws allow us) is OK for small, simple companies that just deal in cash (or at least don't deal in credit for itself or customers) and who want to keep a simple record of where they stand in terms of what money the have at any one moment in time. 

Once a company wants to start selling things on credit, for example, it needs, though, to have a way of keeping track not just of the cash is has now, but also what cash is still owed to it. That is not available to use at this moment, but it will eventually appear (in a perfect world). This starts to allow a company to predict its future, for example. This also means that  when it sells something, cash might not immediately flow into its account (whereas it does for the first transaction in the example above). But in order to keep track of what it is owed, another account needs to be created, so when a customer buys on credit the transaction does not mean money moves into its cash account, but into another account that records other sorts of asset. So, we now have two accounts, and thus we enter the world of double-entry.

Just to anticipate what is coming, we might amend our transactions above further, as in:

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|}
Date & Description  & Account & Amount\\
\hline \hline
1st January 2017 & Sold Tissot watch  & Capital & \$250.00\\
\hline
3rd March 2017 &  Bought can of oil   & Capital & -\$40.00
\end{tabular}
\end{center}
\label{default}
\end{table}%

and even to:

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Income & Expenditure \\
\hline \hline
1st January 2017 & Sold Tissot watch & Capital & \$250.00 & \\
\hline
3rd March 2017 &  Bought can of oil & Capital & & \$40.00
\end{tabular}
\end{center}
\label{default}
\end{table}%


\subsection{Double (and why, and its mad (well...conventional) naming for credits and debits etc)}

In order to keep track of two or more accounts (which give the benefits of being able to deal with credit, loans, invoices etc.)  we have to be more sophisticated with our recording methods. This in turn requires that we have more checks in place so that the more complicated system does not get out of hand. Continuing our example from above shows what is needed.

Our transactions above in the single case would, assuming we now have asset accounts (what the company owns, like stock and cash) and liabilities accounts (like some debt owed to a bank due to a loan from the bank, or an invoice comes in from another company for some asset we bought from them) now become something like:

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Income & Expenditure\\
\hline \hline
1st January 2017 & Sold Tissot watch & Stock &   &\$250.00 \\
\hline
& &  Bank & \$250.00 &  \\
\hline \hline
3rd March 2017 &  Bought can of oil & Bank & & \$40.00  \\
\hline
&  &  Equipment & \$40.00 & 
\end{tabular}
\end{center}
\label{default}
\end{table}%

\noindent and the transaction now has two lines since information about two accounts needs to be recorded.

All the accounts in this expanded example are \emph{asset} accounts, since they are where we hold things we own. (We squashed these three accounts into the Capital account in the previous section.) The main point of this new idea of several accounts, though, is that we can have other sorts of account, so that we can keep track of invoices, say, where we give, essentially, a promise to pay someone for an asset at a later agreed date. So, we don't use an asset to pay for an asset in that transaction, we use a liability (that is, the promise to pay later).

Continuing to make our example more sophisticated, we can introduce a liability account called \emph{Promise to pay} where we record these promises, i.e. invoices sent with goods we receive, to pay later. So our second transaction above now becomes:

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Income & Expenditure\\
\hline \hline
3rd March 2017 &  Bought can of oil & Promise to pay & & \$40.00  \\
\hline
&  &  Equipment & \$40.00 & 
\end{tabular}
\end{center}
\label{default}
\end{table}%

At this point the headings on the last two columns start to be misleading. They made sense when there was just one account that held out assets. But now we have accounts that hold liabilities, and the whole point of them is that we have not, at this moment, spent anything, so \emph{Expenditure} as a title needs changing. The promise to pay later is an increase in liability, so by convention this is viewed as a credit to that account (our liabilities got bigger). Similarly, if our liabilities decrease, because we pay off a promise, then we have debited our liability account. This suggests the following improved headings:

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Debit & Credit\\
\hline \hline
3rd March 2017 &  Bought can of oil & Promise to pay & & \$40.00  \\
\hline
&  &  Equipment & \$40.00 & 
\end{tabular}
\end{center}
\label{default}
\end{table}%

Well, improved in the sense that the rightmost heading now makes sense. But the one next to it? Hm!

But note that the second line of the transaction is talking about an asset account, Equipment, whereas the first was talking about a liability account, so perhaps that difference explains the rather counter-intuitive name in relation to the second line and the penultimate column?

Underlying the double-entry method is the so-called \emph{accounting equation}, which simply says that\footnote{in fact it's a bit more complicated since the right-hand side also mentions ``ownership interest", but here we will just talk about liabilities.} 

\[
assets = liabilities
\]

\noindent being true defines ``the company is keeping its accounts correctly". We have already seen that it makes intuitive sense to say that an increase in liability is a credit in that account. To allow the accounting equation to hold, then, the assets must also increase in this case, but to make the ``balancing" in that transaction apparent (when we see a credit we expect to see a matching debit) then we are forced (to make all this work) to call an increase in an asset a debit. Once this is accepted then we can summarise: increases in liabilities are called credits, and decreases in liabilities are called debits; increases in assets are called debits, and decreases in assets are called credits.

The accounting equation holds for all the accounts if we require, for every transaction, that

\[
debit = credit
\]

So, a global property ``the accounting equation holds" is reduced to a local one ``debit = credit for this transaction". (Room for some Z-style promotion here, surely!) 

This reduction of a global property to a local one (or at least one we can keep track of just by checking each transaction as it happens) probably makes the strange naming convention (which is all it is, we could use any words here) in terms of credit and debit worthwhile.

Finally, here are both our transactions with the new naming:

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Debit & Credit\\
\hline \hline
1st January 2017 & Sold Tissot watch & Stock &   &\$250.00 \\
\hline
& &  Bank & \$250.00 &  \\
\hline \hline
3rd March 2017 &  Bought can of oil & Promise to pay & & \$40.00  \\
\hline
&  &  Equipment & \$40.00 & 
\end{tabular}
\end{center}
\label{default}
\end{table}%

Note that the first transaction all takes place within asset accounts, but the rules still work given the naming conventions.

\subsection{Triple (useful tool for a business planner)}

\subsection{UTXO and Bitcoin}

\subsection{Ethereum and beyond}

%\section{What we intend to cover}
%
%Model Single as the basis
%
%Take Ijiri's view that the "double" refers to two accounts not two entries...hence build double out of single
%
%Triple???

\section{Building a Z model}

\subsection{Single-entry accounting}

We have given sets
 
\[
[DATE, TEXT, MONEY]
\]

and the useful schema

\begin{schema}{Transaction_0}
date : DATE\\
description : TEXT\\
amount : MONEY
\end{schema}

This exactly mirrors a line in the table in Section \ref{singlebasic}. 

Note the schema has no predicate part, so we impose no conditions on the transactions. (Should there be any??)

Now the state space for the account is just a sequence of transactions (with an initial state with no transactions):

\begin{schema}{SingleState}
saccount : \seq Transaction_0
\end{schema}

\begin{schema}{InitSingleState}
SingleState
\where
saccount = < >
\end{schema}

Again, this exactly mirrors the table in Section \ref{singlebasic}. 

Note this schema also has no predicate part, so we impose no conditions on the account. (Should there be any??)

Then we finally have a single state-changing operation, which itself uses an operation that just sets-up a new transaction (this follows a, simplified, version of the Z idiom of promotion...done here just because this might be a useful bit of structuring when things get more complicated later..)

\begin{schema}{NewTransaction_0}
Transaction_0'\\
date? : DATE\\
description? : TEXT\\
amount? : MONEY
\where
date' = date?\\
description' = description?\\
amount' = amount?
\end{schema}

\begin{schema}{\Phi DoSomeBusiness}
\Delta SingleState\\
Transaction'\\
\where
saccount' = saccount \cat < \theta Transaction' >
\end{schema}

We then promote this local operation (which works on a single transaction) to the whole system (``the accounts") using the following\footnote{We have used the convention established by some authors make decades ago of using an initial $\Phi$ to name the \emph{framing schema} for the promotion ($\Phi$ for $F$ in ``Framing", eye-catchingly rendered).}

\[
DoSomeBusiness_0 \defs \exists Transaction_0' @ \Phi DoSomeBusiness \land New Transaction_0
\]

We can generalise a bit (as we did in the previous section) to a transaction that tells us what account name the transaction is dealing with. Clearly in the single-entry case, since there is one, single account under consideration, this is always the same (which is why it isn't mentioned in real systems since it is pointless and wasteful to record this redundant piece of information).

So we amend $Transaction_0$  to

\begin{schema}{Transaction_1}
date : DATE\\
description : TEXT\\
account : ACCOUNT\\
amount : MONEY
\end{schema}

and also add the new given type

\[
[ACCOUNT]
\]

which causes obvious changes to the above Z as follows:

\begin{schema}{NewTransaction_1}
Transaction_1'\\
date? : DATE\\
description? : TEXT\\
account? : ACCOUNT\\ 
amount? : MONEY
\where
date' = date?\\
description' = description?\\
account' = account?\\
amount' = amount?
\end{schema}

\[
DoSomeBusiness_1 \defs \exists Transaction_1' @ \Phi DoSomeBusiness \land New Transaction_1
\]

Finally, again as in the previous section, we introduce the separation of $amount$ to give (and note now that we don't need negative amounts of money to be representable since we have the two ways of recording an amount as either income or expenditure, but we do need a ``blank" amount of money, and exactly one amount has to be blank in each transaction)

\begin{axdef}
blank : MONEY
\end{axdef}

\begin{schema}{Transaction}
date : DATE\\
description : TEXT\\
account : ACCOUNT\\
income : MONEY\\
expenditure : MONEY
\where
(income = blank \land expenditure \neq blank) \\
\lor\\
(income \neq blank \land expenditure = blank)
\end{schema}

which flows on to give

\begin{schema}{NewTransaction}
Transaction'\\
date? : DATE\\
description? : TEXT\\
account? : ACCOUNT\\ 
income? : MONEY\\
expenditure? : MONEY
\where
date' = date?\\
description' = description?\\
account' = account?\\
income' = income?\\
expenditure' = expenditure?
\end{schema}

\[
DoSomeBusiness \defs \exists Transaction' @ \Phi DoSomeBusiness \land NewTransaction
\]

\noindent and $SingleState$ has the obvious definition in terms of this final form for $Transaction$.


(Predicates we might want...keep track of totals amount in and out to make sure it's never below zero? Constrain $account$ to always be the same (our only) account name? 

Also operations like "what is my total balance?" and "compile a report for the month's income and expenses, in summary".)

\subsection{Double-entry accounting}

We aim to formalise the double-entry system in the same way as we have done for single-entry, and then show (as the tables above suggest) that every single-entry transaction and be made more concrete (refined to) a double-entry one. The various operations will follow the same pattern and the usual Z refinement properties will be proved. 

First we define what a double-entry transaction looks like and, as before, what a double-entry state is.  

\begin{schema}{DoubleTransaction}
ddate : DATE\\
ddescription : TEXT\\
account1, account2 : ACCOUNT\\
debit1, debit2, credit1, credit2 : MONEY
\where
(debit1 = credit2 \neq blank \land debit2 = credit1 = blank)\\
\lor\\
(debit2 = credit1 \neq blank \land debit1 = credit2 = blank) 
\end{schema}

\begin{zed}
DoubleState \defs [daccount : \seq DoubleTransaction]
\end{zed}

And similarly to the single-entry case we also have

\begin{schema}{InitDoubleState}
DoubleState
\where
daccount = < >
\end{schema}

\begin{schema}{DoubleNewTransaction}
DoubleTransaction'\\
ddate? : DATE\\
ddescription? : TEXT\\
daccount1?, daccount2? : ACCOUNT\\ 
debit1?, debit2? : MONEY\\
credit1?, credit2? : MONEY
\where
ddate' = ddate?\\
ddescription' = ddescription?\\
account1' = daccount1?\\
account2' = daccount2?\\
debit1' = debit1?\\
debit2' = debit2?\\
credit1' = credit1?\\
credit2' = credit2?
\end{schema}

% **** This is no longer needed since I realised that the conformal inputs take care fo this!!!!****
%Note that we have in fact to specialise the idea of a transaction in the double-entry case because, in general, any two accounts can be involved, but in our claimed refinement we need the extra condition that the two accounts in the double-entry transaction are the same in order to model the single entry case. (See the examples above to see this in action.) So, just for our modelling case we have to make the following special case definition for subsequent use:
%
%\begin{schema}{DoubleNewTransaction_S}
%DoubleTransaction'\\
%ddate? : DATE\\
%ddescription? : TEXT\\
%daccount1?, daccount2? : ACCOUNT\\ 
%debit1?, debit2? : MONEY\\
%credit1?, credit2? : MONEY
%\where
%daccount1? = daccount2?\\
%ddate' = ddate?\\
%ddescription' = ddescription?\\
%daccount1' = daccount1?\\
%daccount2' = daccount2?\\
%debit1' = debit1?\\
%debit2' = debit2?\\
%credit1' = credit1?\\
%credit2' = credit2?
%\end{schema}

\begin{schema}{\Phi DoSomeDoubleBusiness}
\Delta DoubleState\\
DoubleTransaction'\\
\where
daccount' = daccount \cat < \theta DoubleTransaction' >
\end{schema}

\[
DoSomeDoubleBusiness \defs \exists DoubleTransaction' @ \Phi DoSomeDoubleBusiness \land\\
\t14 DoubleNewTransaction
\]

\subsection{Relating single and double}

Consider the tables in the first section. The first transaction in the single system

%\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Income & Expenditure \\
\hline \hline
1st January 2017 & Sold Tissot watch & Capital & \$250.00 & \\
\end{tabular}
\end{center}
\label{default}
%\end{table}%

can first be rewritten as

%\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Income & Expenditure\\
\hline \hline
1st January 2017 & Sold Tissot watch & Capital &   &\$250.00 \\
\hline
& &  Capital & \$250.00 &  \\
\end{tabular}
\end{center}
\label{default}
%\end{table}%

which is simply related to

%\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Debit & Credit\\
\hline \hline
1st January 2017 & Sold Tissot watch & Capital &   &\$250.00 \\
\hline
& &  Capital & \$250.00 &  \\
\end{tabular}
\end{center}
\label{default}
%\end{table}%

If we consider the can of oil too (where capital decreases because we spend it to buy the oil) then we can simply record as we have in the case above. This means recording negative amounts in the two transactions. In a sense, one of the points of double-entry book keeping, though, is that all the amounts recorded are positive. To move to only positive amounts being recorded, but with the information about what amounts were originally negative, we can employ a convention: that a single-entry positive amount is represented as above for the watch; a single-entry negative amount is represented with the transactions in the opposite order, so we would have

%\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Income & Expenditure \\
\hline \hline
3rd March 2017 & Bought can of oil & Capital &  & \$40.00 \\
\end{tabular}
\end{center}
\label{default}
%\end{table}%

represented under the convention by

%\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
Date & Description & Account & Debit & Credit\\
\hline \hline
3rd March 2017 & Bought can of oil  & Capital & \$40  &  \\
\hline
& &  Capital &  & \$40 \\
\end{tabular}
\end{center}
\label{default}
%\end{table}%

thus avoiding use of negative amounts but making it ``clear" what the original information was.

Now, since we have different state space we need to invoke the rules for data refinement (in a Z setting) and to do that we need to say how the two state spaces are related. Here, at last, is where we formalise the picture suggested by the tables above.

We have the schema $R$ which expresses the relationship between the two state spaces:

\begin{schema}{R}
SingleState\\
DoubleState
\where
\# saccount = \# daccount\\
\forall i : \dom saccount @ (
saccount(i).date = daccount(i).ddate \land\\
saccount(i).description = daccount(i).ddescription \land\\
saccount(i).account = daccount(i).account1 = daccount(i).account2 \land\\
saccount(i).income = daccount(i).debit2  = daccount(i).credit1 \land\\
saccount(i).expenditure = daccount(i).credit2 = daccount(i).debit1)
\end{schema}

Then we need to show that the refinement rules hold for any single-entry operation and the  corresponding double-entry operation. The rules are standard (see Derrick and Boiten, for example). We have to take note of the fact that for the Derrick and Boiten predicates they have assumed that the operations are conformal in their inputs, which means that they (at least) have the same number of inputs and the inputs can be ``paired"---essentially we have to think of the inputs in the abstract and concrete versions of any operation we are dealing with as being indexed. We can deal with this by the (somewhat artificial) device of putting all the inputs from the two operations together and letting each operation take all the inputs---and of course each will ignore some of those inputs if they ``came from" the other operation originally. This also needs that the various equalities between the inputs are in the predicate part so that they are enforced. 

This explains why, in what follows, there is only (apparently) one type of input mentioned ($AOp?$ is the inputs to the abstract operation, but because these are also the inputs to the concrete operation we can see that in fact ALL inputs are mentioned). To this end we define a schema that contains all the possible inputs as observations for use in what follows:

\begin{schema}{Inputs}
ddate? : DATE\\
ddescription? : TEXT\\
daccount1?, daccount2? : ACCOUNT\\ 
debit1?, debit2? : MONEY\\
credit1?, credit2? : MONEY\\
date? : DATE\\
description? : TEXT\\
account? : ACCOUNT\\ 
income? : MONEY\\
expenditure? : MONEY
\where
date? = ddate? \\
description? = ddescription?\\
account? = daccount1? = daccount2?\\
income? = debit2? = credit1?\\
expenditure? = debit1? = credit2?
%\lor  ((expenditure? = debit1? = credit2? \neq blank \land income? = debit2? = credit1? = blank))
\end{schema}

The rules state that for any two state spaces $AState$ and $CState$ connected by a relation given by a schema $R$, for any corresponding operation schemas $AOp$ and $COp$ with inputs $AOp?$ the following must hold:\\

\noindent Applicability:
\[
\forall AState; CState; AOp? @ \pre AOp \land R \implies \pre COp
\]

\noindent Correctness:
\[
\forall AState; CState; CState'; AOp? @ \pre AOp \land R \land COp \implies \exists AState' @ R' \land AOp
\]

\noindent and also that there must be corresponding initial states\\

\noindent Init
\[
\forall CState @ CInit \implies \exists AState @ AInit \land R
\]

In our case, if we take the single-entry system to be the abstract state, the double-entry to be the concrete and first consider the appropriate initialisation schemas, we have to prove:

\[
\forall DoubleState  @ InitDoubleState \implies \exists SingleState  @ InitSingleState \land R
\]

Unpacking definitions gives the obligation:

\[
\forall daccount : \seq DoubleTransaction @ daccount = < > \implies\\
\t5 \exists saccount : \seq SingleTransaction @ saccount = < >  \land R
\]

We can use the one-point rule on both

\[
\forall daccount : \seq DoubleTransaction @ daccount = < > \implies...
\]

and
\[
\exists saccount : \seq SingleTransaction @ saccount = < > and \land R
\]

to get

\begin{schema}{}
SingleState\\
DoubleState
\where
\# < > = \# < >\\
\forall i : \dom < > @ (
saccount(i).date = daccount(i).ddate \land\\
saccount(i).description = daccount(i).ddescription \land\\
saccount(i).account = daccount(i).account1 = daccount(i).account2 \land\\
saccount(i).income = daccount(i).debit2  = daccount(i).credit1 \land\\
saccount(i).expenditure = daccount(i).credit2 = daccount(i).debit1)
\end{schema}

\noindent and here the first line is clearly true, and the large universally-quantified predicate is vacuously true. So, initialisation for our system holds.

Next we consider the operations $DoSomeBusiness$ and $DoSomeDoubleBusiness$, which give rise to the obligations of having to prove:

\noindent Applicability:
\[
\forall AState; CState; AOp? @ \pre AOp \land R \implies \pre COp
\]

\noindent Correctness:
\[
\forall AState; CState; CState'; AOp? @ \pre AOp \land R \land COp \implies \exists AState' @ R' \land AOp
\]

By substitution the required predicates specialise to:\\

\noindent Applicability:
\[
\forall SingleState; DoubleState; Inputs @\\
\t4 \pre DoSomeBusiness \land R \implies \pre DoSomeDoubleBusiness
\]
\noindent Correctness:
\[
\forall SingleState; DoubleState; DoubleState'; Inputs @\\
\t4  \pre DoSomeBusiness \land R \land DoSomeDoubleBusiness \implies \\
\t6 \exists SingleState' @ R' \land DoSomeBusiness
\]

We consider Applicability.

We need the preconditions for $DoSomeBusiness$ and $DoSomeDoubleBusiness$ first. By the usual definition we have:
\[
\pre DoSomeBusiness = \exists SingleState' @ (\exists Transaction' @ \Phi DoSomeBusiness \land NewTransaction)
\]
which is
\begin{schema} {}
SingleState\\
date? : DATE\\
description? : TEXT\\
account? : ACCOUNT\\ 
income? : MONEY\\
expenditure? : MONEY
\where
\exists sacc : \seq[Transaction] @\\
      \exists d : Date; desc : DESCRIPTION; a : ACCOUNT; i  : MONEY; e : MONEY) @\\
           (d= date? \land\\
            desc = description? \land \\
            a= account? \land \\
            i = income? \land \\
            e = expenditure? \land \\
            ((i = blank \land e \neq blank) \lor\\ (i \neq blank \land e = blank)) \land\\
            sacc = saccount \cat < \theta Transaction' > )
\end{schema}
\noindent and by using the one-point rule on all the existential quantifications here we can see that the predicate part is just
\[
((income?= blank \land expenditure? \neq blank) \lor\\ (income? \neq blank \land expenditure? = blank)) \land \\ 
saccount  \in \seq[Transaction]
\] 
(where the other requirements for expressions being from the relevant sets are trivially discharged). 

So, any states and inputs (of the correct types) with this combination are states we can start from, do the $DoSomeBusiness$ operation and be sure of ending in a valid state.

The case for $DoSomeDoubleBusiness$ is similar, and we get that its precondition is 
\[
%daccount1? = daccount2? \land \\
((debit1? = credit2? \neq blank \land debit2? = credit1? = blank)\\
\lor\\
(debit2? = credit1? \neq blank \land debit1? = credit2? = blank)) \land \\
daccount \in \seq[DoubleTransaction]
\]


Applicability is then:
\[
\forall SingleState; DoubleState; Inputs @\\
\t1 R \land (((income? = blank \land expenditure? \neq blank) \lor\\ 
\t2   (income? \neq blank \land expenditure? = blank)) \land \\
\t2 saccount  \in \seq[Transaction]) \implies \\
%\t4 daccount1? = daccount2? \land \\
\t4 ((debit1? = credit2? \neq blank \land debit2? = credit1? = blank)\\
\t4\lor\\
\t4(debit2? = credit1? \neq blank \land debit1? = credit2? = blank)) \land \\
\t4daccount \in \seq[DoubleTransaction]
\]

\noindent which expands to the predicate:
\[
\forall saccount : \seq Transaction; daccount:  \seq DoubleTransaction; \\
ddate? : DATE; ddescription? : TEXT daccount1?,daccount2? : ACCOUNT;\\
debit1?,debit2? : MONEY credit1?,credit2? : MONEY;\\
date? : DATE; description? : TEXT; account? : ACCOUNT; income? : MONEY; \\
expenditure? : MONEY @ \\
date? = ddate? \land description? = ddescription? \land account? = daccount1? = daccount2? \land \\
income? = debit2? = credit1? \land expenditure? = debit1? = credit2? \\
%\lor ((expenditure? = debit1? = credit2? \neq blank \land income? = debit2? = credit1? = blank))\\
 \implies \\
\t1  (R \land (income?= blank \land expenditure? \neq blank) \lor\\ 
                  \t2 (income? \neq blank \land expenditure? = blank))\\
\t1 \implies\\
(debit1? = credit2? \neq blank \land debit2? = credit1? = blank)\\
\t4\lor\\
\t1(debit2? = credit1? \neq blank \land debit1? = credit2? = blank))
\]
which is clearly true.

Finally correctness. As we saw, the precondition for $DoSomeBusiness$ is
\[
(income?= blank \land expenditure? \neq blank) \lor (income? \neq blank \land expenditure? = blank)
\]
so correctness in this case is the statement:
\[
\forall SingleState; DoubleState; DoubleState'; Inputs @ \\
\t1 R \land \\
\t1 (income?= blank \land expenditure? \neq blank) \lor (income? \neq blank \land expenditure? = blank)\\
\t1 \land DoSomeDoubleBusiness \implies\\
\t3 \exists SingleState' @ R' \land DoSomeBusiness
\]

To make clearer progress here we look at what, in their ``lowest" terms, the schemas $DoSomeBusiness$ and $DoSomeDoubleBusiness$ are. 
\[
DoSomeBusiness \defs \exists Transaction' @ \Phi DoSomeBusiness \land NewTransaction
\]
so we have this equivalent definition

\begin{schema}{DoSomeBusiness}
\Delta SingleState\\
date? : DATE\\
description? : TEXT\\
account? : ACCOUNT\\ 
income? : MONEY\\
expenditure? : MONEY
\where
\exists d : DATE; desc : TEXT; a : ACCOUNT; i : MONEY; e : MONEY @\\
\t2 saccount' = saccount \cat < \lbind date \mapsto d, description \mapsto desc, \\
\t6 account \mapsto a, income \mapsto i, expenditure \mapsto e  \rbind >\\
\t2 d = date?\\
\t2 desc = description?\\
\t2 a = account?\\
\t2 i= income?\\
\t2 e = expenditure?\\
\t2((i = blank \land e \neq blank) \lor\\
\t2 (i \neq blank \land e = blank))
\end{schema}

which by use of the one-point rule gives the simpler equivalent definition of

\begin{schema}{DoSomeBusiness}
\Delta SingleState\\
date? : DATE\\
description? : TEXT\\
account? : ACCOUNT\\ 
income? : MONEY\\
expenditure? : MONEY
\where
((income? = blank \land expenditure? \neq blank) \lor\\ (income? \neq blank \land expenditure = blank)) \land\\
saccount' = saccount \cat < \lbind date \mapsto date?, description \mapsto description?, \\
\t2 account \mapsto account?, income \mapsto income?, expenditure \mapsto expenditure?  \rbind >\\
\end{schema}

\indent and $DoSomeDoubleBusiness$ similarly has the simpler equivalent definition

\begin{schema}{DoSomeDoubleBusiness}
\Delta DoubleState\\
ddate? : DATE\\
ddescription? : TEXT\\
daccount1?, dacount2? : ACCOUNT\\ 
debit1?, debit2? : MONEY\\
credit1?, credit2? : MONEY
\where
(debit1? = credit2? \neq blank \land debit2? = credit1? = blank)\\
\lor\\
(debit2? = credit1? \neq blank \land debit1? = credit2? = blank)\\
daccount' = daccount \cat \\
\t1 < \lbind ddate \mapsto ddate?, ddescription \mapsto ddescription?, \\
\t3 daccount1 \mapsto daccount1?, daccount2 \mapsto daccount2?, debit1 \mapsto debit1?, \\
\t 4debit2 \mapsto debit2?, credit1 \mapsto credit1?, credit2 \mapsto credit2?  \rbind >\\
\end{schema}

The original statement of correctness is equivalent to
\[
\forall saccount : \seq Transaction; daccount:  \seq DoubleTransaction; \\
ddate? : DATE; ddescription? : TEXT daccount1?,daccount2? : ACCOUNT;\\
debit1?,debit2? : MONEY credit1?,credit2? : MONEY;\\
date? : DATE; description? : TEXT; account? : ACCOUNT; income? : MONEY; \\
expenditure? : MONEY @ \\
date? = ddate? \land description? = ddescription? \land account? = daccount1? = daccount2? \land \\
((income? = debit2? = credit1? \neq blank \land expenditure? = debit1? = credit2? = blank) \lor\\
 ((expenditure? = debit1? = credit2? \neq blank \land income? = debit2? = credit1? = blank))\\
\implies \\
\t1 (R \land \\
\t1 (income?= blank \land expenditure? \neq blank) \lor (income? \neq blank \land expenditure? = blank) \land\\
 \t1 DoSomeDoubleBusiness \implies\\
\t2  \exists saccount' : \seq Transaction @ R' \land DoSomeBusiness)
\]
\noindent which is the predicate
\[
\forall saccount : \seq Transaction; daccount:  \seq DoubleTransaction; \\
ddate? : DATE; ddescription? : TEXT daccount1?,daccount2? : ACCOUNT;\\
debit1?,debit2? : MONEY credit1?,credit2? : MONEY;\\
date? : DATE; description? : TEXT; account? : ACCOUNT; income? : MONEY; \\
expenditure? : MONEY @ \\
date? = ddate? \land description? = ddescription? \land account? = daccount1? = daccount2? \land \\
income? = debit2? = credit1? \land expenditure? = debit1? = credit2? \\
\implies \\
\t1 \# saccount = \# daccount \land \\
\t1 (\forall i : \dom saccount @\\
 \t2 (saccount(i).date = daccount(i).ddate \land\\
       \t2 saccount(i).description = daccount(i).ddescription \land\\
      \t2  saccount(i).account = daccount(i).account1 = daccount(i).account2 \land\\
       \t2 saccount(i).income = daccount(i).debit2  = daccount(i).credit1 \land\\
      \t2 saccount(i).expenditure = daccount(i).credit2 = daccount(i).debit1 ) \land\\
\t1  (income?= blank \land expenditure? \neq blank) \lor (income? \neq blank \land expenditure? = blank) \land \\
\t1((debit1? = credit2? \neq blank \land debit2? = credit1? = blank) \lor\\
\t1(debit2? = credit1? \neq blank \land debit1? = credit2? = blank)) \land\\
\t1daccount' = daccount \cat \\
\t2 < \lbind ddate \mapsto ddate?, ddescription \mapsto ddescription?, \\
\t3 daccount1 \mapsto daccount1?, daccount2 \mapsto daccount2?, debit1 \mapsto debit1?, \\
\t 4debit2 \mapsto debit2?, credit1 \mapsto credit1?, credit2 \mapsto credit2?  \rbind > \\
\t1 \implies\\
\t1 \exists saccount' : \seq Transaction @ \\
\t1saccount' = saccount \cat < \lbind date \mapsto date?, description \mapsto description?, \\
\t2 account \mapsto account?, income \mapsto income?, expenditure \mapsto expenditure?  \rbind >  \land \\
\t1\# saccount' = \# daccount' \land \\
\t1(\forall i : \dom saccount' @\\
\t2 (saccount'(i).date = daccount'(i).ddate \land\\
       \t3 saccount'(i).description = daccount'(i).ddescription \land\\
       \t3 saccount'(i).account = daccount'(i).account1 = daccount'(i).account2 \land\\
       \t3 saccount(i).income = daccount(i).debit2  = daccount(i).credit1 \land\\
       \t3 saccount(i).expenditure = daccount(i).credit2 = daccount(i).debit1) 
\]

%Again we now omit quantification over the inputs where those inputs do not appear, and switch the quantifier as we move it across the implication to get:
%\[
%\forall saccount : \seq Transaction; daccount, daccount' : \seq DoubleTransaction; \\
%\t1expenditure? : MONEY; ddate? : DATE; ddescription? : TEXT \\
%\t1 daccount1?, daccount2? : ACCOUNT;   \\
%\t1 debit1?, debit2? : MONEY; credit1?, credit2? : MONEY;\\
%\t1  income? : MONEY; expenditure? : MONEY@\\
%\# saccount = \# daccount \land \\
%(\forall i : \dom saccount @\\
% \t1 (saccount(i).date = daccount(i).ddate \land\\
%       \t1 saccount(i).description = daccount(i).ddescription \land\\
%      \t1  saccount(i).account = daccount(i).account1 = daccount(i).account2 \land\\
%       \t1 saccount(i).income = daccount(i).debit2 \land\\
%       \t1 saccount(i).expenditure = daccount(i).credit1 ) ) \land\\
%income? = expenditure?  \land \\
%daccount1? = daccount2? \land \\
%(debit1? = credit2? \land debit2? = credit1? = blank)\\
%\lor\\
%(debit2? = credit1? \land debit1? = credit2? = blank)\\ \land
%daccount' = daccount \cat \\
%\t2 < \lbind ddate \mapsto ddate?, ddescription \mapsto ddescription?, \\
%\t3 daccount1 \mapsto daccount1?, daccount2 \mapsto daccount2?, debit1 \mapsto debit1?, \\
%\t 4debit2 \mapsto debit2?, credit1 \mapsto credit1?, credit2 \mapsto credit2?  \rbind > \\
%\implies\\
%\exists saccount' : \seq Transaction; date? : DATE; description? : TEXT; \\ 
%\t2 account? : ACCOUNT@ \\
%\# saccount' = \# daccount' \land \\
%(\forall i : \dom saccount' @\\
%\t1 (saccount'(i).date = daccount'(i).ddate \land\\
%       \t1 saccount'(i).description = daccount'(i).ddescription \land\\
%       \t1 saccount'(i).account = daccount'(i).account1 = daccount'(i).account2 \land\\
%       \t1 saccount'(i).income = daccount'(i).debit2 \land\\
%       \t1 saccount'(i).expenditure = daccount'(i).credit1)) \land\\
%saccount' = saccount \cat < \lbind date \mapsto date?, description \mapsto description?, \\
%\t2 account \mapsto account?, income \mapsto income?, expenditure \mapsto expenditure?  \rbind >
%\]
%

The inner antecedent tells us that the two sequences $saccount'$ and $daccount'$ have the relationship required in the consequent for all elements from their beginnings up to the length of $saccount$. Also, given that the lengths of the two sequences $saccount$ and $daccount$ are given as equal in the antecedent, and given that $saccount'$ and $daccount'$ are both just one element longer than $saccount$ and $daccount$, it follows that $saccount'$ and $daccount'$ have the same length. 

Then all that is left to prove is that the two new elements added to the two new sequences have the correct relationship, and this follows from the predicates that give us conformality of inputs.

%Then all that is left to prove is that the two new elements added to the two sequences have the correct relationship, i.e. that
%\[
%\forall saccount : \seq Transaction; daccount, daccount' : \seq DoubleTransaction; \\
%\t1 date? : DATE; description? : TEXT; account? : ACCOUNT; income? : MONEY\\
%\t1expenditure? : MONEY; ddate? : DATE; ddescription? : TEXT; \\
%\t1 daccount1?, daccount2? : ACCOUNT; \\
%\t1 debit1?, debit2? : MONEY; credit1?, credit2? : MONEY@\\
%date? = ddate? \land description? = ddescription? \land daccount1? = daccount2? \land\\
%((debit1? = credit2? \land debit2? = credit1? = blank) \lor\\
%(debit2? = credit1? \land debit1? = credit2? = blank)) \\
%\implies \\
% \t2 \exists date? : DATE; description? : TEXT; account? : ACCOUNT @ \\
%\t3 date? = ddate? \land description? = ddescription? \land \\
%\t3 account? = daccount1? = daccount2? \land \\
%\t3 income? = debit2? \land expenditure? = credit1?
%\]
%
%and this follows from a cases analysis and several uses of the one-point rule.

Hence we have shown that double-entry accounting is a refinement of single-entry accounting.

\subsection{Triple-entry accounting (aka Momentum accounting)}

Triple---and again?

\subsection{UTXO accounting}

For a UTXO model, an account's balance is not explicitly stored anywhere
(officially; it might be kept track of in the "wallet" that someone keeps,
but that is not part of the blockchain).
 
We start with some basic constants and types.

%Cash moved about varies in size, so we use natural numbers
%\[  
%Cash : TYPE = nat
%\]

% All possible account numbers--a few here for illustrative purposes
% The mechanisms of account use (spending, mainly) are abstracted (hidden)
% in this version
% \[
%  AccountNo : TYPE = {a0, a1, a2, a3, a4, a5, a6, a7, a8, a9}
%\]

%
%Of the possible accounts, these are the currently used ones
% \[
%  LiveAccounts : TYPE = set[AccountNo]
%  \]
%
%Transactions have a name--here are a few
% \[
% TransactionName : TYPE = {t0, t1, t2, t3, t4, t5, t6, t7, t8, t9}
% \]
%
% We need to be able to find one particular output amongst the outputs
% of a transaction, so we have an index
% \[
%  Index : TYPE = nat
%\]

The cash that gets moved around in a UTXO system is not fixed in size. (When we want to try out this model we will probably concretise $CASH$ by $\nat$, but for now we stay most abstract with a given type. The same concretisation point goes for $ACCOUNTNO$ and $TRANSACTIONNAME$ too.)

%($INDEX$ might also be kept abstract, but I've elected to use sequences, so we might as well have $INDEX$ as a $\nat$. I don't see a lot to be gained in terms of abstraction by having the indexed collections of outputs that a transaction refers as anything more abstract than sequences (though any injection will do, of course.)) 

Note that the mechanisms for secure account use (spending, mainly) are abstracted (hidden) in this version. 

%We keep track of all the live (i.e. known) accounts with $LiveAccounts$. This might not be sensible...we'll see.
%\[
%LiveAccounts : \power AccountNo
%\]

Any inputs to a transaction indicate where value is being taken from: some previous
 transaction (identified by its name), and which of its outputs (identified by who is spending their money). And outputs are identified here by the person who owns them, how much they are worth and in which transaction they were given the money:
 
% \[
%  TransInput \defs [transaction : TRANSACTIONNAME, output : INDEX]
%\]
%This is the toothpuller's version

 \[
  TransInput \defs [transaction : TRANSACTIONNAME, spender : ACCOUNTNO]
\]


Something to prove here is that an input only refers to a previous transaction.

Any outputs from a transaction say how much cash they contain and who owns it
\[
  TransOutput \defs [name : TRANSACTIONNAME, cash : CASH, owner : ACCOUNTNO]
 \]
 
(I guess we don't need to show that the owner is a current live account? There are accounts with no live owners. Though this would be useful to consider further as it has a bearing on reproducing some of the results in the ``Suicidal" paper...)
                       
 We are representing a transaction by how much is being transferred from where (which inputs)
 and to where (which outputs), together with its name (and a requirement that all the outputs in a transaction are tagged with its name). So we have:
 
\begin{schema}{Transaction}
name : TRANSACTIONNAME\\
inputs : \power TransInput\\
outputs : \power TransOutput
\where
\forall o : outputs @ o.name = name
\end{schema}

Finally, this is the state of the blockchain abstracted to just show all the accepted, recorded transactions:
 \[
  BCstatetype == \seq Transaction
\]

 The outputs of a transaction form a set (transactions only output one coin to each account that they pay to, so if there are equal amounts of cash they are distinguishable by the owner's account number).
 
 Also an owner might have, say, two coins with the same cash value. But they will each ``reside" in different transactions' outputs (transactions only output one coin to each account that they pay to), so they remain distinguishable. 
 
% However, if the owner then uses these two coins as inputs to a transaction (to make up the value required) then do we need then to be able to distinguish them? No, because given the transactions they were each, identifiably and uniquely, amongst the outputs of, which means that the owner has only one coin in each of those outputs, we can tell which coins are being spent.
 
When it comes to identifying all the unspent coins at a certain point in the history of a blockchain, what then? At any given point in the evolution of the blockchain we have a list of valid, accepted (by consensus) transactions. At this point, the unspent coins are the unspent outputs in any transaction that has appeared so far. 
 
An output is unspent if it has not been used as an input to some subsequent transaction. Now consider the smallest blockchain, or sequence of transactions: it has just one block and all the coins in its outputs are unspent coins (and note that this starting block breaches the value input equals value output requirement which we use later, so it must be special, of course). 
 
Now consider adding a transaction: the inputs to this transaction must be amongst those output by the first, special, transaction, and after this second transaction the unspent coins are the outputs from the first transaction, (set) minus the coins input to the second transaction (which must be amongst those output by the first transaction), unioned with the coins output from the second transaction (none of which can have been used yet since this is the last transaction in the sequence, i.e. on the blockchain.) 
 
 We can see that, by induction, as a generalisation of this story, the unspent output for a sequence of transactions of the form $< h > \cat t$ is the unspent outputs from the tail (sequence) $t$, (set) minus the coins input to the (head) transaction $h$, unioned with the outputs of $h$. And to start the inductive definition the unspent outputs of the initial blockchain are all the outputs of that first transaction which is the sole transaction at that point. To summarise, we define:
 \[
 unspentOutputs\ <h > =_{def} h.outputs\\
 unspentOutputs\ < h > \cat t =_{def} unspentOutputs(t) \setminus ItoO(h,t)\  \cup\ h.outputs
 \]
 
 Note that we cannot simply use $h.inputs$ as the second term in the second right-hand side above (consider the types!), so we need the function $ItoO$ to map $h.inputs$ to the outputs within $t$ that they are each formed from. We have:
 \[
ItoO(h, <>)  =_{def} \emptyset\\
ItoO(h, < h' > \cat t  ) =_{def} ItoO(h, t) \cup\\
\t2 \bigcup_{i \in h.inputs}  \{ c : CASH | i.transaction = h'.name \land \\
\t3 \exists o' : TransOutput | o' \in h'.outputs @ i.spender = o'.owner \land o'.cash = c @ \\
\t4 \lbind  name \bindsto h'.name, cash \bindsto c, owner \bindsto h.spender \rbind \}
 \]

A transaction in UTXO is $valid$ as long as:
\begin{itemize}
\item
 the cash input and the cash output are the same (remember we are hiding anything to do with the $security$ of account use for now; not to do so would mean also requiring that the sender can prove ownership of the coin that is being sent---orthogonal, and perhaps something to do later)
 \item
  and all the inputs in the current transaction were amongst the outputs of previously occurring valid transactions.
\end{itemize}

Here are the formal counterparts of those two components for validity for any blockchain $bc : BCstatetype$---the first is the equality of inputs and outputs for any transaction and the second says that all the inputs of a transaction must be unspent outputs from previous transactions:

\[
\forall trans : Transaction; i : \nat | i \mapsto trans \in bc @\\
          \t2 sum\_out\ trans.outputs = sum\_in\  trans.inputs
\]
where $sum\_out$ sums all the cash values in the outputs, and $sum\_in$ sums all the cash values ``in" the inputs by referring back to the output that the input is formed from in each case;

\[
\forall trans : Transaction | i \mapsto trans \in  bc @\\
         \t2 \forall input : TransInput | input \in trans.inputs @ \\
                     \t5input \in unspentOutputs ((0..i-1) \dres bc)
\]


\subsection{Ethereum-style contracts and accounting}

To come.

\end{document}

\section{Rough notes as a plan, some of which is done}

?Information used for control settles contracts and commitments and must therefore reside as data shared among the relevant parties? Demski p.160

?Accounting?a science that studies information in an economic context? p.164 Demski 2002.

Transactions are the basis of everything. See Ijiri for example. So that?s where we start.

They have three things observable (at least?might be info about where to find the details in a journal somewhere???):

Type says whether it?s to do with Assets, Liabilities or Owner Inputs

Then there must be exactly two other things observable: amount and where the detail is, for debits; amount and where the detail is, for credits. These two things form the foundation of double-entry book keeping (DEBK) (there are two entries). One question is?.while transitions are the basis of all accounting, clearly not all of them are double-entry?so is this already too specialised? And if so, what is a more general form of transaction? Ijiri would be useful here too.

In fact Ijiri says ?not just that each transaction is being entered in two different accounts, but that transactions are accounted for by two different systems of accounts. ?Double? refers not to the entries, but to the systems of account used to record transactions? (p.28) in Yuji Ijiri, "Momentum Accounting and Triple-Entry Bookkeeping: Exploring the Dynamic Structure of Accounting Measurements", Studies in Accounting Research, volume 31, American Accounting Association, 1989. 

Double-Entry forces the identification of causal connections.


Refs

?Some thoughts on the Intellectual Foundations of Accounting?, Demski et al., 2002

\end{document}
